function hazard = climada_rf_hazard_set(centroids, precip_file, hazard_set_file,x_fraction, ens_size, ens_amp, check_plots)
% climada RF hazard event set
% NAME:
%   climada_RF_hazard_set
% PURPOSE:
%   Construct hazard set structure from global historical daily precipitation data
%   found here: ftp://ftp.cgd.ucar.edu/archive/PRECIP/GPCP_1DD_v1.2_199610-201407.nc.gz
%               http://www.esrl.noaa.gov/psd/data/gridded/data.gpcc.html
%   The ens_size probabilistic events are generated by taking the x_fraction most
%   extreme events from the original data, and adjusting their intensity.
%   The extent of the wiggle is determined by generating a random wiggle
%   paramater from a normal distribution with standard deviation ens_amp.
% CALLING SEQUENCE:
%   hazard = climada_rf_hazard_set(centroids, precip_file, x_fraction, ens_size, ens_amp, hazard_set_file, check_plots)
% EXAMPLE:
%   hazard = climada_rf_hazard_set(centroids, '', 0.2, 9, 0.1, 'NO_SAVE', 1)
%   hazard = climada_rf_hazard_set(centroids, '', 0.7, 1)
%   hazard = climada_rf_hazard_set
% INPUTS:
%   hazard_set_file: the name of the newly created rainfall (RF) hazard
%       > promted for if not given
% OPTIONAL INPUT PARAMETERS:
%   check_plots: whether to show plots (default = 1)
% OUTPUTS:
%   hazard:     a hazard event set, see core climada doc
%               also written to a .mat file (see hazard_set_file)
% MODIFICATION HISTORY:
% Gilles Stassen, gillesstassen@hotmail.com, 20150316
% Gilles Stassen, gillesstassen@hotmail.com, 20150406 overhaul to daily
%                   precipitation data, including auto download functionality, and
%                   probabilistic set of extreme events
%-

hazard = []; % init

global climada_global
if ~climada_init_vars,return;end % init/import global variables

% poor man's version to check arguments
if ~exist('precip_file',        'var'), precip_file         ='';        end
if ~exist('hazard_set_file',    'var'), hazard_set_file     ='';        end
if ~exist('centroids',          'var'), centroids           =[];        end
if ~exist('x_fraction',         'var'), x_fraction          =[];        end
if ~exist('ens_size',           'var'), ens_size            =[];        end
if ~exist('ens_amp',            'var'), ens_amp             =[];        end
if ~exist('check_plots',        'var'), check_plots         =0;         end

if isempty(x_fraction), x_fraction  = 0.05;                             end
if isempty(ens_size),   ens_size    = max(round((1/x_fraction)/2)-1,0); end
if isempty(ens_amp),    ens_amp     = 0.05;                             end


% PARAMETERS

module_data_dir=[fileparts(fileparts(mfilename('fullpath'))) filesep 'data'];
if ~isdir(module_data_dir),mkdir(fileparts(module_data_dir),'data');end % create the data dir, should it not exist (no further checking)

if isempty(precip_file) || ~ischar(precip_file) || (~isempty(precip_file) && ~exist(precip_file, 'file'))
    precip_file  = 'GPCP_1DD_v1.2_199610-201407.nc';
    try
        precip_file = subdir([module_data_dir filesep precip_file]);
    catch
        precip_file = subdir([root_dir filesep precip_file]);
        precip_dir  = fileparts(precip_file.name);
    end
    init_time = datenum(1990,01,01); % hard wired for GPCP
    
    if isempty(precip_file)
        if climada_global.waitbar
            warn_msg = sprintf(['WARNING: GPCP precipitation data file not found \n' ...
                '\t \t would you like to browse existing files (b) or download directly (d)?']);
            response = input(warn_msg,'s');
        else
            response = 'd';
        end
        switch response
            case 'd'
                fprintf('downloading and unzipping global daily precipitation data from NASA''s GCPC data set... ')
                precip_URL = 'ftp://ftp.cgd.ucar.edu/archive/PRECIP/GPCP_1DD_v1.2_199610-201407.nc.gz';
                precip_file = gunzip(precip_URL,[module_data_dir filesep 'precip_data']);
                fprintf('done \n')
            case 'b'
                [fN, fP] = uigetfile('*.nc', 'Select precipitation data file');
                if isequal(fN,0) || isequal(fP,0),
                    cprintf([0.25 0.25 1],['NOTE: click '...
                        '<a href="ftp://ftp.cgd.ucar.edu/archive/PRECIP/GPCP_1DD_v1.2_199610-201407.nc.gz">'...
                        'here</a> to download global monthly precipitation data \n']);
                    return;
                end
                init_time   = input('specify start time yyyy/mm/dd of data set: ','s');
                init_time   = datenum(init_time,'yyyy/mm/dd');
                precip_file = [fP fN];
            otherwise
                cprintf([1 0 0], 'ERROR: invalid response \n')
                return
        end
    else
        precip_file = precip_file.name;
    end
    
    fprintf('reading global daily precipitation data... ')
    precip_nc_info = ncinfo(precip_file);
    for fld_i =  1 : numel(precip_nc_info.Variables)
        var_name = precip_nc_info.Variables(fld_i).Name;
        tmp_p_d.(var_name)=ncread(precip_file,var_name);
    end
    fprintf('done \n')
elseif exist(precip_file, 'file')
    [fP, fN, fE] = fileparts(precip_file);
    if strcmp(fE,'.mat')
        load(precip_file);
    elseif strcmp(fE, '.nc')
        fprintf('reading global daily precipitation data... ')
        precip_nc_info = ncinfo(precip_file);
        for fld_i =  1 : numel(precip_nc_info.Variables)
            var_name = precip_nc_info.Variables(fld_i).Name;
            tmp_p_d.(var_name)=ncread(precip_file,var_name);
        end
        fprintf('done\n')
        if climada_global.waitbar
            init_time   = input('specify start time yyyy/mm/dd of data set: ','s');
            init_time   = datenum(init_time,'yyyy/mm/dd');
        else 
            init_time = datenum(1990,01,01); % hard wired for GPCP
        end
    else
        cprintf([1 0 0], 'ERROR: invalid file type - input file must be .mat or .nc \n')
        return
    end
end

if ~isstruct(centroids)
    centroids = climada_centroids_load;
    if ~isstruct(centroids),fprintf('abort \n'); return; end
end

% prep the region we need (rectangular region encompassing the hazard centroids)
centroids_rect=[min(centroids.lon) max(centroids.lon) min(centroids.lat) max(centroids.lat)];

% determine fields
flds = fieldnames(tmp_p_d);
for fld_i = 1: numel(flds)
    if ndims(tmp_p_d.(flds{fld_i})) == 3
        tmp_p_d.precip = tmp_p_d.(flds{fld_i});
    end
end

% restructure gridded data in array format
[lon,lat] = meshgrid(tmp_p_d.lon,tmp_p_d.lat);
p_data.lon      = reshape(lon,[numel(lon) 1]);
p_data.lat      = reshape(lat,[numel(lat) 1]);
p_data.precip   = reshape(tmp_p_d.precip,[numel(lon) size(tmp_p_d.precip,3)]);

% old:
% [p_data.precip, p_data.lon, p_data.lat]=climada_grid2array(permute(tmp_p_d.precip,[1 2 3]), tmp_p_d.lon, tmp_p_d.lat);

if max(p_data.lon) > 180, p_data.lon = p_data.lon - 180; end

p_data.time = double(tmp_p_d.time) + init_time;

% for testing purposes
% cprintf([1 0.5 0],'WARNING: only first two years of rainfall data taken for testing purposes - line 162 in climada_rf_hazard_set\n')
% p_data.precip   = p_data.precip(:,1:730);
% p_data.time     = p_data.time  (  1:730);

% select relevant spatial region
bb = 0.5*min(diff(p_data.lon));   % buffer
s_ndx = (p_data.lon >= floor(centroids_rect(1))-bb & p_data.lon <= ceil(centroids_rect(2))+bb) & ...
    (p_data.lat >= floor(centroids_rect(3))-bb & p_data.lat <= ceil(centroids_rect(4))+bb);

p_data.lon      = double(p_data.lon(s_ndx));
p_data.lat      = double(p_data.lat(s_ndx));
p_data.precip   = double(p_data.precip(s_ndx,:));
clear s_ndx tmp_p_d


% prompt for hazard_set_file if not given
if isempty(hazard_set_file) % local GUI
    hazard_set_file=[module_data_dir filesep 'hazards' filesep 'RF_hazard.mat'];
    [fN, fP] = uiputfile(hazard_set_file, 'Save new RF hazard event set as:');
    if isequal(fN,0) || isequal(fP,0)
        return; % cancel
    else
        hazard_set_file=fullfile(fP,fN);
    end
end

p_data.yyyy             = str2num(datestr(p_data.time,'yyyy'));
p_data.mm               = str2num(datestr(p_data.time,'mm'));
p_data.dd               = str2num(datestr(p_data.time,'dd'));

orig_years  = max(p_data.yyyy) - min(p_data.yyyy) +1;

if ens_size >0
    % Construct p_data_x struct with x_fraction most extreme events
    p_data_x.lon                = p_data.lon;
    p_data_x.lat                = p_data.lat;
    p_data_x.precip             = [];
    p_data_x.orig_event_flag    = [];
    p_data_x.time               = [];
    p_data_x.yyyy               = [];
    p_data_x.mm                 = [];
    p_data_x.dd                 = [];
    for year_i = min(p_data.yyyy):max(p_data.yyyy)
        % subset for year_i
        p_data_year_i.precip    = p_data.precip (:,p_data.yyyy == year_i);
        p_data_year_i.time      = p_data.time   (  p_data.yyyy == year_i);
        p_data_year_i.yyyy      = p_data.yyyy   (  p_data.yyyy == year_i);
        p_data_year_i.mm        = p_data.mm     (  p_data.yyyy == year_i);
        p_data_year_i.dd        = p_data.dd     (  p_data.yyyy == year_i);

        % number of non-zero rain events per year
        nz      = sum(sum(p_data_year_i.precip,1)~=0);
        % number of extreme events of interest
        nx      = ceil(x_fraction * nz);

        [~,ndx] = sort(sum(p_data_year_i.precip,1),'descend');

        for x_i = ndx(1:nx)
            % generate wiggle matrix by drawing random numbers from normal dist
            % normrnd in stats toolbox, use randn
            % wiggle_matrix   = normrnd(1,ens_amp,length(p_data.lon),ens_size);
            wiggle_matrix   = 1 + ens_amp .* randn(length(p_data.lon),ens_size);
            p_data_x.precip(:,end+1)    = p_data_year_i.precip(:,x_i);
            p_data_x.precip(:,end+1:end+ens_size) = bsxfun(@times,p_data_year_i.precip(:,x_i),wiggle_matrix);

            p_data_x.orig_event_flag(end+1)                 = 1;
            p_data_x.orig_event_flag(end+1:end+ens_size)    = 0;

            p_data_x.time(end+1:end+ens_size+1)   = p_data_year_i.time(x_i);
            p_data_x.yyyy(end+1:end+ens_size+1)   = p_data_year_i.yyyy(x_i);
            p_data_x.mm  (end+1:end+ens_size+1)   = p_data_year_i.mm  (x_i);
            p_data_x.dd  (end+1:end+ens_size+1)   = p_data_year_i.dd  (x_i);
        end
    end
else
    p_data_x                 	= p_data;
    p_data_x.orig_event_flag	= ones(size(p_data.time));
end

% set NaNs to zero
p_data_x.precip(isnan(p_data_x.precip)) = 0;

% fill the hazard structure
hazard.reference_year   = climada_global.present_reference_year; % default for present hazard is normally 2010
hazard.lon              = centroids.lon;
hazard.lat              = centroids.lat;
hazard.centroid_ID      = centroids.centroid_ID;
if isfield(centroids,'elevation_m'),hazard.elevation_m=centroids.elevation_m;end
hazard.orig_years       = orig_years;

hazard.orig_event_count = sum   (p_data_x.orig_event_flag);
hazard.event_count      = length(p_data_x.orig_event_flag);
hazard.event_ID         = 1:hazard.event_count;
hazard.orig_event_flag  = p_data_x.orig_event_flag';
hazard.yyyy             = p_data_x.yyyy';
hazard.mm               = p_data_x.mm';
hazard.dd               = p_data_x.dd';
hazard.datenum          = p_data_x.time';

event_frequency         = 1/(orig_years*(ens_size+1));
hazard.frequency        = ones(1,hazard.event_count)*event_frequency;

hazard.peril_ID         = 'RF';
hazard.comment          =sprintf('RF hazard event set, generated %s',datestr(now));

% hazard.intensity        = spalloc(hazard.event_count,length(hazard.lon),ceil(hazard.event_count*length(hazard.lon)*0.3));
hazard.intensity        = zeros(hazard.event_count,numel(centroids.centroid_ID));
fprintf('processing RF precipitation at centroids for %i events...\n',hazard.event_count)
mod_step = 10; format_str = '%s'; t0 = clock;

[LON, LAT]  = meshgrid(unique(p_data_x.lon),unique(p_data_x.lat));

for event_i = 1:hazard.event_count
    if any(any(p_data_x.precip(:,event_i)))
        
        if length(p_data_x.lon) >1
            % gridded_p_x = griddata(p_data_x.lon,p_data_x.lat,p_data_x.precip(:,event_i),LON,LAT);
            % hazard.intensity(event_i,:)=interp2(LON, LAT, squeeze(gridded_p_x),hazard.lon,hazard.lat,'linear');
        
            F_p_x = scatteredInterpolant(p_data_x.lon,p_data_x.lat,p_data_x.precip(:,event_i),'linear','nearest');
            hazard.intensity(event_i,:)=F_p_x(hazard.lon,hazard.lat);
        else
            hazard.intensity(event_i,:)= ones(size(centroids.centroid_ID)).* p_data_x.precip(:,event_i);
        end
    end
    % the progress management
    if mod(event_i,mod_step)==0
        mod_step          = 100;
        t_elapsed_event   = etime(clock,t0)/event_i;
        events_remaining  = hazard.event_count-event_i;
        t_projected_sec   = t_elapsed_event*events_remaining;
        if t_projected_sec<60
            msgstr = sprintf('est. %3.0f sec left (%i/%i events)',t_projected_sec,event_i,hazard.event_count);
        else
            msgstr = sprintf('est. %3.1f min left (%i/%i events)',t_projected_sec/60,event_i,hazard.event_count);
        end
        fprintf(format_str,msgstr); % write progress to stdout
        format_str=[repmat('\b',1,length(msgstr)) '%s']; % back to begin of line
    end
end
fprintf(strcat('\b',format_str, '\n'),'done');

% hazard.intensity    = sparse(hazard.intensity);
format_str = '%s';
fprintf(format_str,sprintf('processing rainfall at %i centroids for %i events took %3.1f seconds \n', ...
    numel(hazard.centroid_ID),hazard.event_count,etime(clock,t0)));

if isfield(hazard,'filename'),hazard.filename_source=hazard.filename;end
hazard.filename=hazard_set_file;
hazard.date=datestr(now);
hazard.matrix_density=nnz(hazard.intensity)/numel(hazard.intensity);
hazard.units='mm'; % store the SI unit of the hazard intensity

if ~strcmp(hazard_set_file,'NO_SAVE');
    fprintf('saving RF rainfall hazard set as %s\n',hazard_set_file);
    try
        save(hazard_set_file,'hazard');
    catch
        cprintf([1 0 0], 'ERROR: can not write to file, try saving RF hazard manually \n')
    end
end

if check_plots,figure('color','w'); climada_hazard_plot_hr(hazard,0);end % show max rainfall over ALL events

return
